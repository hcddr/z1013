	cpu	Z80
;**************************************************************
;*
;*                TINY BASIC FOR INTEL 8080
;*                      VERSION 1.0
;*                    BY LI-CHEN WANG
;*                     10 JUNE, 1976
;*                       @COPYLEFT
;*                  ALL WRONGS RESERVED
;*
;**************************************************************
;*
;*  ;*** ZERO PAGE SUBROUTINES ***
;*
;*  THE 8080 INSTRUCTION SET LETS YOU HAVE 8 ROUTINES IN LOW
;*  MEMORY THAT MAY BE CALLED BY RST N, N BEING 0 THROUGH 7.
;*  THIS IS A ONE BYTE INSTRUCTION AND HAS THE SAME POWER AS
;*  THE THREE BYTE INSTRUCTION CALL LLHH.  TINY BASIC WILL
;*  USE RST 0 AS START AND RST 1 THROUGH RST 7 FOR
;*  THE SEVEN MOST FREQUENTLY USED SUBROUTINES.
;*  TWO OTHER SUBROUTINES (CRLF AND TSTNUM) ARE ALSO IN THIS
;*  SECTION.  THEY CAN BE REACHED ONLY BY 3-BYTE CALLS.
;*  IN ORDER TO CONFIGURE THE SYSTEM FOR USE WITH CPM I HAVE
;*  MOVED SOME OF THE ROUTINES AROUND.  START WILL NOW BE AT
;*  LOCATION 100H AND THIS SECTION WILL END AT LOCATION 3FH
;*  WITH A JUMP TO 108H.
;*
;       ORG  8H
;       XTHL           ;*** TSTC OR RST 1 ***
;       RST  5         ;IGNORE BLANKS AND
;       CMP  M         ;TEST CHARACTER
;       JMP  TC1       ;REST OF THIS IS AT TC1
;*
;CRLF   MVI  A,0DH     ;*** CRLF ***
;*
;       PUSH PSW       ;*** OUTC OR RST 2 ***
;       LDA  OCSW      ;PRINT CHARACTER ONLY
;       ORA  A         ;IFF OCSW SWITCH IS ON
;       JMP  OC2       ;REST OF THIS IS AT OC2
;*
;       CALL EXPR2     ;*** EXPR OR RST 3 ***
;       PUSH H         ;EVALUATE AN EXPRESION
;       JMP  EXPR1     ;REST OF IT IS AT EXPR1
;       DB   'W'
;*
;       MOV  A,H       ;*** COMP OR RST 4 ***
;       CMP  D         ;COMPARE HL WITH DE
;       RNZ            ;RETURN CORRECT C AND
;       MOV  A,L       ;Z FLAGS
;       CMP  E         ;BUT OLD A IS LOST
;       RET
;       DB   'AN'
;*
;SS1    LDAX D         ;*** IGNBLK/RST 5 ***
;       CPI  40Q       ;IGNORE BLANKS
;       RNZ            ;IN TEXT (WHERE DE->)
;       INX  D         ;AND RETURN THE FIRST
;       JMP  SS1       ;NON-BLANK CHAR. IN A
;*
;       POP  PSW       ;*** FINISH/RST 6 ***
;       CALL FIN       ;CHECK END OF COMMAND
;       JMP  QWHAT     ;PRINT "WHAT?" IFF WRONG
;       DB   'G'
;*
;       RST  5         ;*** TSTV OR RST 7 ***
;       SUI  100Q      ;TEST VARIABLES
;       RC             ;C:NOT A VARIABLE
;       JMP  TSTV1     ;JUMP AROUND RESERVED AREA
		ORG	100H	;OF CPM.
START:		JP	NINIT	;GO TO INITIALIZATION ROUTINE.	JIF
TSTV1:		JP	NZ,TV1	;NOT "@" ARRAY
		INC	DE	;IT IS THE "@" ARRAY
		CALL	PARN	;@ SHOULD BE FOLLOWED
		ADD	HL,HL	;BY (EXPR) AS ITS INDEX
		JP	C,QHOW	;IS INDEX TOO BIG?
		PUSH	DE	;WILL IT OVERWRITE
		EX	DE,HL	;TEXT?
		CALL	SIZE	;FIND SIZE OF FREE
		RST	20H	;AND CHECK THAT
		JP	C,ASORRY	;IFF SO, SAY "SORRY"
SS1A:		LD	HL,VARBGN	;IFF NOT, GET ADDRESS
		CALL	SUBDE	;OF @(EXPR) AND PUT IT
		POP	DE	;IN HL
		RET	;C FLAG IS CLEARED
TV1:		CP	33O	;NOT @, IS IT A TO Z?
		CCF	;IFF NOT RETURN C FLAG
		RET	C
		INC	DE	;IFF A THROUGH Z
TV1A:		LD	HL,VARBGN	;COMPUTE ADDRESS OF
		RLCA	;THAT VARIABLE
		ADD	A,L	;AND RETURN IT IN HL
		LD	L,A	;WITH C FLAG CLEARED
		LD	A,0
		ADC	A,H
		LD	H,A
		RET
;*
;*                 TSTC   XCH  HL,(SP)   ;*** TSTC OR RST 1 ***
;*                        IGNBLK         THIS IS AT LOC. 8
;*                        CMP  M         AND THEN JMP HERE
TC1:		INC	HL	;COMPARE THE BYTE THAT
		JP	Z,TC2	;FOLLOWS THE RST INST.
		PUSH	BC	;WITH THE TEXT (DE->)
		LD	C,(HL)	;IFF NOT =, ADD THE 2ND
		LD	B,0	;BYTE THAT FOLLOWS THE
		ADD	HL,BC	;RST TO THE OLD PC
		POP	BC	;I.E., DO A RELATIVE
		DEC	DE	;JUMP IFF NOT =
TC2:		INC	DE	;IFF =, SKIP THOSE BYTES
		INC	HL	;AND CONTINUE
		EX	(SP),HL
		RET
;*
TSTNUM:		LD	HL,0	;*** TSTNUM ***
		LD	B,H	;TEST IFF THE TEXT IS
		RST	28H	;A NUMBER
TN1:		CP	60O	;IFF NOT, RETURN 0 IN
		RET	C	;B AND HL
		CP	72O	;IFF NUMBERS, CONVERT
		RET	NC	;TO BINARY IN HL AND
		LD	A,360O	;SET A TO # OF DIGITS
		AND	H	;IFF H>255, THERE IS NO
		JP	NZ,QHOW	;ROOM FOR NEXT DIGIT
		INC	B	;B COUNTS # OF DIGITS
		PUSH	BC
		LD	B,H	;HL=10;*HL+(NEW DIGIT)
		LD	C,L
		ADD	HL,HL	;WHERE 10;* IS DONE BY
		ADD	HL,HL	;SHIFT AND ADD
		ADD	HL,BC
		ADD	HL,HL
		LD	A,(DE)	;AND (DIGIT) IS FROM
		INC	DE	;STRIPPING THE ASCII
		AND	17O	;CODE
		ADD	A,L
		LD	L,A
		LD	A,0
		ADC	A,H
		LD	H,A
		POP	BC
		LD	A,(DE)	;DO THIS DIGIT AFTER
		JP	P,TN1	;DIGIT. S SAYS OVERFLOW
QHOW:		PUSH	DE	;*** ERROR: "HOW?" ***
AHOW:		LD	DE,HOW
		JP	ERROR
HOW:		DB	"HOW?",0DH
OK:		DB	"OK",0DH
WHAT:		DB	"WHAT?",0DH
SORRY:		DB	"SORRY",0DH
;*
;**************************************************************
;*
;* *** MAIN ***
;*
;* THIS IS THE MAIN LOOP THAT COLLECTS THE TINY BASIC PROGRAM
;* AND STORES IT IN THE MEMORY.
;*
;* AT START, IT PRINTS OUT "(CR)OK(CR)", AND INITIALIZES THE
;* STACK AND SOME OTHER INTERNAL VARIABLES.  THEN IT PROMPTS
;* ">" AND READS A LINE.  IFF THE LINE STARTS WITH A NON-ZERO
;* NUMBER, THIS NUMBER IS THE LINE NUMBER.  THE LINE NUMBER
;* (IN 16 BIT BINARY) AND THE REST OF THE LINE (INCLUDING CR)
;* IS STORED IN THE MEMORY.  IFF A LINE WITH THE SAME LINE
;* NUMBER IS ALREDY THERE, IT IS REPLACED BY THE NEW ONE.  IF
;* THE REST OF THE LINE CONSISTS OF A 0DHONLY, IT IS NOT STORED
;* AND ANY EXISTING LINE WITH THE SAME LINE NUMBER IS DELETED.
;*
;* AFTER A LINE ISs INSERTED, REPLACED, OR DELETED, THE PROGRAM
;* LOOPS BACK AND ASK FOR ANOTHER LINE.  THIS LOOP WILL BE
;* TERMINATED WHEN IT READS A LINE WITH ZERO OR NO LINE
;* NUMBER; AND CONTROL IS TRANSFERED TO "DIRCT".
;*
;* TINY BASIC PROGRAM SAVE AREA STARTS AT THE MEMORY LOCATION
;* LABELED "TXTBGN" AND ENDED AT "TXTEND".  WE ALWAYS FILL THIS
;* AREA STARTING AT "TXTBGN", THE UNFILLED PORTION IS POINTED
;* BY THE CONTENT OF A MEMORY LOCATION LABELED "TXTUNF".
;*
;* THE MEMORY LOCATION "CURRNT" POINTS TO THE LINE NUMBER
;* THAT IS CURRENTLY BEING INTERPRETED.  WHILE WE ARE IN
;* THIS LOOP OR WHILE WE ARE INTERPRETING A DIRECT COMMAND
;* (SEE NEXT SECTION), "CURRNT" SHOULD POINT TO A 0.
;*
RSTART:		LD	SP,STACK	;SET STACK POINTER
ST1:		CALL	CRLF	;AND JUMP TO HERE
		LD	DE,OK	;DE->STRING
		SUB	A	;A=0
		CALL	PRTSTG	;PRINT STRING UNTIL 0DH
		LD	HL,ST2+1	;LITERAL 0
		LD	(CURRNT),HL	;CURRNT->LINE # = 0
ST2:		LD	HL,0
		LD	(LOPVAR),HL
		LD	(STKGOS),HL
ST3:		LD	A,76O	;PROMPT '>' AND
		CALL	GETLN	;READ A LINE
		PUSH	DE	;DE->END OF LINE
ST3A:		LD	DE,BUFFER	;DE->BEGINNING OF LINE
		CALL	TSTNUM	;TESt IFF IT IS A NUMBER
		RST	28H
		LD	A,H	;HL=VALUE OF THE # OR
		OR	L	;0 IFF NO # WAS FOUND
		POP	BC	;BC->END OF LINE
		JP	Z,DIRECT
		DEC	DE	;BACKUP DE AND SAVE
		LD	A,H	;VALUE OF LINE # THERE
		LD	(DE),A
		DEC	DE
		LD	A,L
		LD	(DE),A
		PUSH	BC	;BC,DE->BEGIN, END
		PUSH	DE
		LD	A,C
		SUB	E
		PUSH	AF	;A=# OF BYTES IN LINE
		CALL	FNDLN	;FIND THIS LINE IN SAVE
		PUSH	DE	;AREA, DE->SAVE AREA
		JP	NZ,ST4	;NZ:NOT FOUND, INSERT
		PUSH	DE	;Z:FOUND, DELETE IT
		CALL	FNDNXT	;FIND NEXT LINE
;*                                       DE->NEXT LINE
		POP	BC	;BC->LINE TO BE DELETED
		LD	HL,(TXTUNF)	;HL->UNFILLED SAVE AREA
		CALL	MVUP	;MOVE UP TO DELETE
		LD	H,B	;TXTUNF->UNFILLED AREA
		LD	L,C
		LD	(TXTUNF),HL	;UPDATE
ST4:		POP	BC	;GET READY TO INSERT
		LD	HL,(TXTUNF)	;BUT FIRT CHECK IF
		POP	AF	;THE LENGTH OF NEW LINE
		PUSH	HL	;IS 3 (LINE # AND CR)
		CP	3	;THEN DO NOT INSERT
		JP	Z,RSTART	;MUST CLEAR THE STACK
		ADD	A,L	;COMPUTE NEW TXTUNF
		LD	L,A
		LD	A,0
		ADC	A,H
		LD	H,A	;HL->NEW UNFILLED AREA
ST4A:		LD	DE,TXTEND	;CHECK TO SEE IF THERE
		RST	20H	;IS ENOUGH SPACE
		JP	NC,QSORRY	;SORRY, NO ROOM FOR IT
		LD	(TXTUNF),HL	;OK, UPDATE TXTUNF
		POP	DE	;DE->OLD UNFILLED AREA
		CALL	MVDOWN
		POP	DE	;DE->BEGIN, HL->END
		POP	HL
		CALL	MVUP	;MOVE NEW LINE TO SAVE
		JP	ST3	;AREA
;*
;**************************************************************
;*
;* *** TABLES *** DIRECT *** & EXEC ***
;*
;* THIS SECTION OF THE CODE TESTS A STRING AGAINST A TABLE.
;* WHEN A MATCH IS FOUND, CONTROL IS TRANSFERED TO THE SECTION
;* OF CODE ACCORDING TO THE TABLE.
;*
;* AT 'EXEC', DE SHOULD POINT TO THE STRING AD HL SHOULD POINT
;* TO THE TABLE-1.  AT 'DIRECT', DE SHOULD POINT TO THE STRING,
;* HL WILL BE SET UP TO POINT TO TAB1-1, WHICH IS THE TABLE OF
;* ALL DIRECT AND STATEMENT COMMANDS.
;*
;* A '.' IN THE STRING WILL TERMINATE THE TEST AND THE PARTIAL
;* MATCH WILL BE CONSIDERED AS A MATCH.  E.G., 'P.', 'PR.',
;* 'PRI.', 'PRIN.', OR 'PRINT' WILL ALL MATCH 'PRINT'.
;*
;* THE TABLE CONSISTS OF ANY NUMBER OF ITEMS.  EACH ITEM
;* IS A STRING OF CHARACTERS WITH BIT 7 SET TO 0 AND
;* A JUMP ADDRESS STORED HI-LOW WITH BIT 7 OF THE HIGH
;* BYTE SET TO 1.
;*
;* END OF TABLE IS AN ITEM WITH A JUMP ADDRESS ONLY.  IFF THE
;* STRING DOES NOT MATCH ANY OF THE OTHER ITEMS, IT WILL
;* MATCH THIS NULL ITEM AS DEFAULT.
;*
TAB1		EQU	$	;DIRECT COMMANDS
		DB	"LIST"
		DB	LIST >> 8 + 128,LIST & 0FFH
		DB	"RUN"
		DB	RUN >> 8 + 128,RUN & 255
		DB	"NEW"
		DB	NEW >> 8 + 128,NEW & 255
		DB	"LOAD"
		DB	DLOAD >> 8 + 128,DLOAD & 255
		DB	"SAVE"
		DB	DSAVE >> 8 + 128,DSAVE & 255
		DB	"BYE",80H,0H	;GO BACK TO CPM
TAB2		EQU	$	;DIRECT/TATEMENT
		DB	"NEXT"
		DB	NEXT >> 8 + 128,NEXT & 255
		DB	"LET"
		DB	LET >> 8 + 128,LET & 255
		DB	"OUT"
		DB	OUTCMD >> 8 + 128,OUTCMD & 255
		DB	"POKE"
		DB	POKE >> 8 + 128,POKE & 255
		DB	"WAIT"
		DB	WAITCM >> 8 + 128,WAITCM & 255
		DB	"IF"
		DB	IFF >> 8 + 128,IFF & 255
		DB	"GOTO"
		DB	GOTO >> 8 + 128,GOTO & 255
		DB	"GOSUB"
		DB	GOSUB >> 8 + 128,GOSUB & 255
		DB	"RETURN"
		DB	RETURN >> 8 + 128,RETURN & 255
		DB	"REM"
		DB	REM >> 8 + 128,REM & 255
		DB	"FOR"
		DB	FOR >> 8 + 128,FOR & 255
		DB	"INPUT"
		DB	INPUT >> 8 + 128,INPUT & 255
		DB	"PRINT"
		DB	PRINT >> 8 + 128,PRINT & 255
		DB	"STOP"
		DB	STOP >> 8 + 128,STOP & 255
		DB	DEFLT >> 8 + 128,DEFLT & 255
		DB	"YOU CAN ADD MORE"	;COMMANDS BUT
;REMEMBER TO MOVE DEFAULT DOWN.
TAB4		EQU	$	;FUNCTIONS
		DB	"RND"
		DB	RND >> 8 + 128,RND & 255
		DB	"INP"
		DB	INP >> 8 + 128,INP & 255
		DB	"PEEK"
		DB	PEEK >> 8 + 128,PEEK & 255
		DB	"USR"
		DB	USR >> 8 + 128,USR & 255
		DB	"ABS"
		DB	ABS >> 8 + 128,ABS & 255
		DB	"SIZE"
		DB	SIZE >> 8 + 128,SIZE & 255
		DB	XP40 >> 8 + 128,XP40 & 255
		DB	"YOU CAN ADD MORE"	;FUNCTIONS BUT REMEMBER
;TO MOVE XP40 DOWN
TAB5		EQU	$	;"TO" IN "FOR"
		DB	"TO"
		DB	FR1 >> 8 + 128,FR1 & 255
		DB	QWHAT >> 8 + 128,QWHAT & 255
TAB6		EQU	$	;"STEP" IN "FOR"
		DB	"STEP"
		DB	FR2 >> 8 + 128,FR2 & 255
		DB	FR3 >> 8 + 128,FR3 & 255
TAB8		EQU	$	;RELATION OPERATORS
		DB	">="
		DB	XP11 >> 8 + 128,XP11 & 255
		DB	"#"
		DB	XP12 >> 8 + 128,XP12 & 255
		DB	">"
		DB	XP13 >> 8 + 128,XP13 & 255
		DB	"="
		DB	XP15 >> 8 + 128,XP15 & 255
		DB	"<="
		DB	XP14 >> 8 + 128,XP14 & 255
		DB	"<"
		DB	XP16 >> 8 + 128,XP16 & 255
		DB	XP17 >> 8 + 128,XP17 & 255
;*
DIRECT:		LD	HL,TAB1-1	;*** DIRECT ***
;*
EXEC		EQU	$	;*** EXEC ***
EX0:		RST	28H	;IGNORE LEADING BLANKS
		PUSH	DE	;SAVE POINTER
EX1:		LD	A,(DE)	;IFF FOUND '.' IN STRING
		INC	DE	;BEFORE ANY MISMATCH
		CP	56O	;WE DECLARE A MATCH
		JP	Z,EX3
		INC	HL	;HL->TABLE
		CP	(HL)	;IFF MATCH, TEST NEXT
		JP	Z,EX1
		LD	A,177O	;ELSE, SEE IFF BIT 7
		DEC	DE	;OF TABLEIS SET, WHICH
		CP	(HL)	;IS THE JUMP ADDR. (HI)
		JP	C,EX5	;C:YES, MATCHED
EX2:		INC	HL	;NC:NO, FIND JUMP ADDR.
		CP	(HL)
		JP	NC,EX2
		INC	HL	;BUMP TO NEXT TAB. ITEM
		POP	DE	;RESTORE STRING POINTER
		JP	EX0	;TEST AGAINST NEXT ITEM
EX3:		LD	A,177O	;PARTIAL MATCH, FIND
EX4:		INC	HL	;JUMP ADDR., WHICH IS
		CP	(HL)	;FLAGGED BY BIT 7
		JP	NC,EX4
EX5:		LD	A,(HL)	;LOAD HL WITH THE JUMP
		INC	HL	;ADDRESS FROM THE TABLE
		LD	L,(HL)
		AND	177O	;MASK OFF BIT 7
		LD	H,A
		POP	AF	;CLEAN UP THE GABAGE
		JP	(HL)	;AND WE GO DO IT
;*
;**************************************************************
;*
;* WHAT FOLLOWS IS THE CODE TO EXECUTE DIRECT AND STATEMENT
;* COMMANDS.  CONTROL IS TRANSFERED TO THESE POINTS VIA THE
;* COMMAND TABLE LOOKUP CODE OF 'DIRECT' AND 'EXEC' IN LAST
;* SECTION.  AFTER THE COMMAND IS EXECUTED, CONTROL IS
;* TANSFERED TO OTHER SECTIONS AS FOLLOWS:
;*
;* FOR 'LIST', 'NEW', AND 'STOP': GO BACK TO 'RSTART'
;* FOR 'RUN': GO EXECUTE THE FIRST STORED LINE IFF ANY; ELSE
;* GO BACK TO 'RSTART'.
;* FOR 'GOTO' AND 'GOSUB': GO EXECUTE THE TARGET LINE.
;* FOR 'RETURN' AND 'NEXT': GO BACK TO SAVED RETURN LINE.
;* FOR ALL OTHERS: IFF 'CURRNT' -> 0, GO TO 'RSTART', ELSE
;* GO EXECUTE NEXT COMMAND.  (THIS IS DONE IN 'FINISH'.)
;*
;**************************************************************
;*
;* *** NEW *** STOP *** RUN (& FRIENDS) *** & GOTO ***
;*
;* 'NEW(CR)' SETS 'TXTUNF' TO POINT TO 'TXTBGN'
;*
;* 'STOP(CR)' GOES BACK TO 'RSTART'
;*
;* 'RUN(CR)' FINDS THE FIRST STORED LINE, STORE ITS ADDRESS (IN
;* 'CURRNT'), AND START EXECUTE IT.  NOTE THAT ONLY THOSE
;* COMMANDS IN TAB2 ARE LEGAL FOR STORED PROGRAM.
;*
;* THERE ARE 3 MORE ENTRIES IN 'RUN':
;* 'RUNNXL' FINDS NEXT LINE, STORES ITS ADDR. AND EXECUTES IT.
;* 'RUNTSL' STORES THE ADDRESS OF THIS LINE AND EXECUTES IT.
;* 'RUNSML' CONTINUES THE EXECUTION ON SAME LINE.
;*
;* 'GOTO EXPR(CR)' EVALUATES THE EXPRESSION, FIND THE TARGET
;* LINE, AND JUMP TO 'RUNTSL' TO DO IT.
;* 'DLOAD' LOADS A NAMED PROGRAM FROM DISK.
;* 'DSAVE' SAVES A NAMED PROGRAM ON DISK.
;* 'FCBSET' SETS UP THE FILE CONTROL BLOCK FOR SUBSEQUENT DISK I/O.
;*
NEW:		CALL	ENDCHK	;*** NEW(CR) ***
		LD	HL,TXTBGN
		LD	(TXTUNF),HL
;*
STOP:		CALL	ENDCHK	;*** STOP(CR) ***
		JP	RSTART
;*
RUN:		CALL	ENDCHK	;*** RUN(CR) ***
		LD	DE,TXTBGN	;FIRST SAVED LINE
;*
RUNNXL:		LD	HL,0	;*** RUNNXL ***
		CALL	FNDLNP	;FIND WHATEVER LINE #
		JP	C,RSTART	;C:PASSED TXTUNF, QUIT
;*
RUNTSL:		EX	DE,HL	;*** RUNTSL ***
		LD	(CURRNT),HL	;SET 'CURRNT'->LINE #
		EX	DE,HL
		INC	DE	;BUMP PASS LINE #
		INC	DE
;*
RUNSML:		CALL	CHKIO	;*** RUNSML ***
		LD	HL,TAB2-1	;FIND COMMAND IN TAB2
		JP	EXEC	;AND EXECUTE IT
;*
GOTO:		RST	18H	;*** GOTO EXPR ***
		PUSH	DE	;SAVE FOR ERROR ROUTINE
		CALL	ENDCHK	;MUST FIND A 0DH
		CALL	FNDLN	;FIND THE TARGET LINE
		JP	NZ,AHOW	;NO SUCH LINE #
		POP	AF	;CLEAR THE "PUSH DE"
		JP	RUNTSL	;GO DO IT
CPM		EQU	5	;DISK PARAMETERS
FCB		EQU	5CH
SETDMA		EQU	26
OPEN		EQU	15
READD		EQU	20
WRITED		EQU	21
CLOSE		EQU	16
MAKE		EQU	22
DELETE		EQU	19
;*
DLOAD:		RST	28H	;IGNORE BLANKS
		PUSH	HL	;SAVE H
		CALL	FCBSET	;SET UP FILE CONTROL BLOCK
		PUSH	DE	;SAVE THE REST
		PUSH	BC
		LD	DE,FCB	;GET FCB ADDRESS
		LD	C,OPEN	;PREPARE TO OPEN FILE
		CALL	CPM	;OPEN IT
		CP	0FFH	;IS IT THERE?
		JP	Z,QHOW	;NO, SEND ERROR
		XOR	A	;CLEAR A
		LD	(FCB+32),A	;START AT RECORD 0
		LD	DE,TXTUNF	;GET BEGINNING
LOAD:		PUSH	DE	;SAVE DMA ADDRESS
		LD	C,SETDMA;
		CALL	CPM	;SET DMA ADDRESS
		LD	C,READD;
		LD	DE,FCB
		CALL	CPM	;READ SECTOR
		CP	1	;DONE?
		JP	C,RDMORE	;NO, READ MORE
		JP	NZ,QHOW	;BAD READ
		LD	C,CLOSE
		LD	DE,FCB
		CALL	CPM	;CLOSE FILE
		POP	DE	;THROW AWAY DMA ADD.
		POP	BC	;GET OLD REGISTERS BACK
		POP	DE
		POP	HL
		RST	30H	;FINISH
RDMORE:		POP	DE	;GET DMA ADDRESS
		LD	HL,80H	;GET 128
		ADD	HL,DE	;ADD 128 TO DMA ADD.
		EX	DE,HL	;PUT IT BACK IN D
		JP	LOAD	;AND READ SOME MORE
;*
DSAVE:		RST	28H	;IGNORE BLANKS
		PUSH	HL	;SAVE H
		CALL	FCBSET	;SETUP FCB
		PUSH	DE
		PUSH	BC	;SAVE OTHERS
		LD	DE,FCB
		LD	C,DELETE
		CALL	CPM	;ERASE FILE IF IT EXISTS
		LD	DE,FCB
		LD	C,MAKE
		CALL	CPM	;MAKE A NEW ONE
		CP	0FFH	;IS THERE SPACE?
		JP	Z,QHOW	;NO, ERROR
		XOR	A	;CLEAR A
		LD	(FCB+32),A	;START AT RECORD 0
		LD	DE,TXTUNF	;GET BEGINNING
SAVE:		PUSH	DE	;SAVE DMA ADDRESS
		LD	C,SETDMA;
		CALL	CPM	;SET DMA ADDRESS
		LD	C,WRITED
		LD	DE,FCB
		CALL	CPM	;WRITE SECTOR
		OR	A	;SET FLAGS
		JP	NZ,QHOW	;IF NOT ZERO, ERROR
		POP	DE	;GET DMA ADD. BACK
		LD	A,(TXTUNF+1)	;AND MSB OF LAST ADD.
		CP	D	;IS D SMALLER?
		JP	C,SAVDON	;YES, DONE
		JP	NZ,WRITMOR	;DONT TEST E IF NOT EQUAL
		LD	A,(TXTUNF)	;IS E SMALLER?
		CP	E
		JP	C,SAVDON	;YES, DONE
WRITMOR:	LD	HL,80H
		ADD	HL,DE	;ADD 128 TO DMA ADD.
		EX	DE,HL	;GET IT BACK IN D
		JP	SAVE	;WRITE SOME MORE
SAVDON:		LD	C,CLOSE
		LD	DE,FCB
		CALL	CPM	;CLOSE FILE
		POP	BC	;GET REGISTERS BACK
		POP	DE
		POP	HL
		RST	30H	;FINISH
;*
FCBSET:		LD	HL,FCB	;GET FILE CONTROL BLOCK ADDRESS
		LD	(HL),0	;CLEAR ENTRY TYPE
FNCLR:		INC	HL	;NEXT LOCATION
		LD	(HL),' '	;CLEAR TO SPACE
		LD	A,FCB+8 & 255
		CP	L	;DONE?
		JP	NZ,FNCLR	;NO, DO IT AGAIN
		INC	HL	;NEXT
		LD	(HL),'T'	;SET FILE TYPE TO 'TBI'
		INC	HL
		LD	(HL),'B'
		INC	HL
		LD	(HL),'I'
EXRC:		INC	HL	;CLEAR REST OF FCB
		LD	(HL),0
		LD	A,FCB+15 & 255
		CP	L	;DONE?
		JP	NZ,EXRC	;NO, CONTINUE
		LD	HL,FCB+1	;GET FILENAME START
FN:		LD	A,(DE)	;GET CHARACTER
		CP	0DH	;IS IT A 'CR'
		RET	Z	;YES, DONE
		CP	'!'	;LEGAL CHARACTER?
		JP	C,QWHAT	;NO, SEND ERROR
		CP	'['	;AGAIN
		JP	NC,QWHAT	;DITTO
		LD	(HL),A	;SAVE IT IN FCB
		INC	HL	;NEXT
		INC	DE
		LD	A,FCB+9 & 255
		CP	L	;LAST?
		JP	NZ,FN	;NO, CONTINUE
		RET	;TRUNCATE AT 8 CHARACTERS
;*
;*************************************************************
;*
;* *** LIST *** & PRINT ***
;*
;* LIST HAS TWO FORMS:
;* 'LIST(CR)' LISTS ALL SAVED LINES
;* 'LIST #(CR)' START LIST AT THIS LINE #
;* YOU CAN STOP THE LISTING BY CONTROL C KEY
;*
;* PRINT COMMAND IS 'PRINT ....;' OR 'PRINT ....(CR)'
;* WHERE '....' IS A LIST OF EXPRESIONS, FORMATS, BACK-
;* ARROWS, AND STRINGS.  THESE ITEMS ARE SEPERATED BY COMMAS.
;*
;* A FORMAT IS A POUND SIGN FOLLOWED BY A NUMBER.  IT CONTROLSs
;* THE NUMBER OF SPACES THE VALUE OF A EXPRESION IS GOING TO
;* BE PRINTED.  IT STAYS EFFECTIVE FOR THE REST OF THE PRINT
;* COMMAND UNLESS CHANGED BY ANOTHER FORMAT.  IFF NO FORMAT IS
;* SPECIFIED, 6 POSITIONS WILL BE USED.
;*
;* A STRING IS QUOTED IN A PAIR OF SINGLE QUOTES OR A PAIR OF
;* DOUBLE QUOTES.
;*
;* A BACK-ARROW MEANS GENERATE A (CR) WITHOUT (LF)
;*
;* A (CRLF) IS GENERATED AFTER THE ENTIRE LIST HAS BEEN
;* PRINTED OR IFF THE LIST IS A NULL LIST.  HOWEVER IFF THE LIST
;* ENDED WITH A COMMA, NO (CRL) IS GENERATED.
;*
LIST:		CALL	TSTNUM	;TEST IFF THERE IS A #
		CALL	ENDCHK	;IFF NO # WE GET A 0
		CALL	FNDLN	;FIND THIS OR NEXT LINE
LS1:		JP	C,RSTART	;C:PASSED TXTUNF
		CALL	PRTLN	;PRINT THE LINE
		CALL	CHKIO	;STOP IFF HIT CONTROL-C
		CALL	FNDLNP	;FIND NEXT LINE
		JP	LS1	;AND LOOP BACK
;*
PRINT:		LD	C,6	;C = # OF SPACES
		RST	08H	;IFF NULL LIST & ";"
		DB	73O
		DB	6O
		CALL	CRLF	;GIVE CR-LF AND
		JP	RUNSML	;CONTINUE SAME LINE
PR2:		RST	08H	;IFF NULL LIST (CR)
		DB	0DH
		DB	6O
		CALL	CRLF	;ALSO GIVE CR-LF AND
		JP	RUNNXL	;GO TO NEXT LINE
PR0:		RST	08H	;ELSE IS IT FORMAT?
		DB	'#'
		DB	5O
		RST	18H	;YES, EVALUATE EXPR.
		LD	C,L	;AND SAVE IT IN C
		JP	PR3	;LOOK FOR MORE TO PRINT
PR1:		CALL	QTSTG	;OR IS IT A STRING?
		JP	PR8	;IFF NOT, MUST BE EXPR.
PR3:		RST	08H	;IFF ",", GO FIND NEXT
		DB	','
		DB	6O
		CALL	FIN	;IN THE LIST.
		JP	PR0	;LIST CONTINUES
PR6:		CALL	CRLF	;LIST ENDS
		RST	30H
PR8:		RST	18H	;EVALUATE THE EXPR
		PUSH	BC
		CALL	PRTNUM	;PRINT THE VALUE
		POP	BC
		JP	PR3	;MORE TO PRINT?
;*
;**************************************************************
;*
;* *** GOSUB *** & RETURN ***
;*
;* 'GOSUB EXPR;' OR 'GOSUB EXPR (CR)' IS LIKE THE 'GOTO'
;* COMMAND, EXCEPT THAT THE CURRENT TEXT POINTER, STACK POINTER
;* ETC. ARE SAVE SO THAT EXECUTION CAN BE CONTINUED AFTER THE
;* SUBROUTINE 'RETURN'.  IN ORDER THAT 'GOSUB' CAN BE NESTED
;* (AND EVEN RECURSIVE), THE SAVE AREA MUST BE STACKED.
;* THE STACK POINTER IS SAVED IN 'STKGOS'. THE OLD 'STKGOS' IS
;* SAVED IN THE STACK.  IFF WE ARE IN THE MAIN ROUTINE, 'STKGOS'
;* IS ZERO (THIS WAS DONE BY THE "MAIN" SECTION OF THE CODE),
;* BUT WE STILL SAVE IT AS A FLAG FORr NO FURTHER 'RETURN'S.
;*
;* 'RETURN(CR)' UNDOS EVERYHING THAT 'GOSUB' DID, AND THUS
;* RETURN THE EXCUTION TO THE COMMAND AFTER THE MOST RECENT
;* 'GOSUB'.  IFF 'STKGOS' IS ZERO, IT INDICATES THAT WE
;* NEVER HAD A 'GOSUB' AND IS THUS AN ERROR.
;*
GOSUB:		CALL	PUSHA	;SAVE THE CURRENT "FOR"
		RST	18H	;PARAMETERS
		PUSH	DE	;AND TEXT POINTER
		CALL	FNDLN	;FIND THE TARGET LINE
		JP	NZ,AHOW	;NOT THERE. SAY "HOW?"
		LD	HL,(CURRNT)	;FOUND IT, SAVE OLD
		PUSH	HL	;'CURRNT' OLD 'STKGOS'
		LD	HL,(STKGOS)
		PUSH	HL
		LD	HL,0	;AND LOAD NEW ONES
		LD	(LOPVAR),HL
		ADD	HL,SP
		LD	(STKGOS),HL
		JP	RUNTSL	;THEN RUN THAT LINE
RETURN:		CALL	ENDCHK	;THERE MUST BE A 0DH
		LD	HL,(STKGOS)	;OLD STACK POINTER
		LD	A,H	;0 MEANS NOT EXIST
		OR	L
		JP	Z,QWHAT	;SO, WE SAY: "WHAT?"
		LD	SP,HL	;ELSE, RESTORE IT
		POP	HL
		LD	(STKGOS),HL	;AND THE OLD 'STKGOS'
		POP	HL
		LD	(CURRNT),HL	;AND THE OLD 'CURRNT'
		POP	DE	;OLD TEXT POINTER
		CALL	POPA	;OLD "FOR" PARAMETERS
		RST	30H	;AND WE ARE BACK HOME
;*
;**************************************************************
;*
;* *** FOR *** & NEXT ***
;*
;* 'FOR' HAS TWO FORMS:
;* 'FOR VAR=EXP1 TO EXP2 STEP EXP1' AND 'FOR VAR=EXP1 TO EXP2'
;* THE SECOND FORM MEANS THE SAME THING AS THE FIRST FORM WITH
;* EXP1=1.  (I.E., WITH A STEP OF +1.)
;* TBI WILL FIND THE VARIABLE VAR. AND SET ITS VALUE TO THE
;* CURRENT VALUE OF EXP1.  IT ALSO EVALUATES EXPR2 AND EXP1
;* AND SAVE ALL THESE TOGETHER WITH THE TEXT POINTERr ETC. IN
;* THE 'FOR' SAVE AREA, WHICH CONSISTS OF 'LOPVAR', 'LOPINC',
;* 'LOPLMT', 'LOPLN', AND 'LOPPT'.  IFF THERE IS ALREADY SOME-
;* THING IN THE SAVE AREA (THIS IS INDICATED BY A NON-ZERO
;* 'LOPVAR'), THEN THE OLD SAVE AREA IS SAVED IN THE STACK
;* BEFORE THE NEW ONE OVERWRITES IT.
;* TBI WILL THEN DIG IN THE STACK AND FIND OUT IFF THIS SAME
;* VARIABLE WAS USED IN ANOTHER CURRENTLY ACTIVE 'FOR' LOOP.
;* IFF THAT IS THE CASE THEN THE OLD 'FOR' LOOP IS DEACTIVATED.
;* (PURGED FROM THE STACK..)
;*
;* 'NEXT VAR' SERVES AS THE LOGICAL (NOT NECESSARILLY PHYSICAL)
;* END OF THE 'FOR' LOOP.  THE CONTROL VARIABLE VAR. IS CHECKED
;* WITH THE 'LOPVAR'.  IFF THEY ARE NOT THE SAME, TBI DIGS IN
;* THE STACK TO FIND THE RIGHTt ONE AND PURGES ALL THOSE THAT
;* DID NOT MATCH.  EITHER WAY, TBI THEN ADDS THE 'STEP' TO
;* THAT VARIABLE AND CHECK THE RESULT WITH THE LIMIT.  IFF IT
;* IS WITHIN THE LIMIT, CONTROL LOOPS BACK TO THE COMMAND
;* FOLLOWING THE 'FOR'.  IFF OUTSIDE THE LIMIT, THE SAVE ARER
;* IS PURGED AND EXECUTION CONTINUES.
;*
FOR:		CALL	PUSHA	;SAVE THE OLD SAVE AREA
		CALL	SETVAL	;SET THE CONTROL VAR.
		DEC	HL	;HL IS ITS ADDRESS
		LD	(LOPVAR),HL	;SAVE THAT
		LD	HL,TAB5-1	;USE 'EXEC' TO LOOK
		JP	EXEC	;FOR THE WORD 'TO'
FR1:		RST	18H	;EVALUATE THE LIMIT
		LD	(LOPLMT),HL	;SAVE THAT
		LD	HL,TAB6-1	;USE 'EXEC' TO LOOK
		JP	EXEC	;FOR THE WORD 'STEP'
FR2:		RST	18H	;FOUND IT, GET STEP
		JP	FR4
FR3:		LD	HL,1O	;NOT FOUND, SET TO 1
FR4:		LD	(LOPINC),HL	;SAVE THAT TOO
FR5:		LD	HL,(CURRNT)	;SAVE CURRENT LINE #
		LD	(LOPLN),HL
		EX	DE,HL	;AND TEXT POINTER
		LD	(LOPPT),HL
		LD	BC,12O	;DIG INTO STACK TO
		LD	HL,(LOPVAR)	;FIND 'LOPVAR'
		EX	DE,HL
		LD	H,B
		LD	L,B	;HL=0 NOW
		ADD	HL,SP	;HERE IS THE STACK
		DB	76O
FR7:		ADD	HL,BC	;EACH LEVEL IS 10 DEEP
		LD	A,(HL)	;GET THAT OLD 'LOPVAR'
		INC	HL
		OR	(HL)
		JP	Z,FR8	;0 SAYS NO MORE IN IT
		LD	A,(HL)
		DEC	HL
		CP	D	;SAME AS THIS ONE?
		JP	NZ,FR7
		LD	A,(HL)	;THE OTHER HALF?
		CP	E
		JP	NZ,FR7
		EX	DE,HL	;YES, FOUND ONE
		LD	HL,0O
		ADD	HL,SP	;TRY TO MOVE SP
		LD	B,H
		LD	C,L
		LD	HL,12O
		ADD	HL,DE
		CALL	MVDOWN	;AND PURGE 10 WORDS
		LD	SP,HL	;IN THE STACK
FR8:		LD	HL,(LOPPT)	;JOB DONE, RESTORE DE
		EX	DE,HL
		RST	30H	;AND CONTINUE
;*
NEXT:		RST	38H	;GET ADDRESS OF VAR.
		JP	C,QWHAT	;NO VARIABLE, "WHAT?"
		LD	(VARNXT),HL	;YES, SAVE IT
NX0:		PUSH	DE	;SAVE TEXT POINTER
		EX	DE,HL
		LD	HL,(LOPVAR)	;GET VAR. IN 'FOR'
		LD	A,H
		OR	L	;0 SAYS NEVER HAD ONE
		JP	Z,AWHAT	;SO WE ASK: "WHAT?"
		RST	20H	;ELSE WE CHECK THEM
		JP	Z,NX3	;OK, THEY AGREE
		POP	DE	;NO, LET'S SEE
		CALL	POPA	;PURGE CURRENT LOOP
		LD	HL,(VARNXT)	;AND POP ONE LEVEL
		JP	NX0	;GO CHECK AGAIN
NX3:		LD	E,(HL)	;COME HERE WHEN AGREED
		INC	HL
		LD	D,(HL)	;DE=VALUE OF VAR.
		LD	HL,(LOPINC)
		PUSH	HL
		ADD	HL,DE	;ADD ONE STEP
		EX	DE,HL
		LD	HL,(LOPVAR)	;PUT IT BACK
		LD	(HL),E
		INC	HL
		LD	(HL),D
		LD	HL,(LOPLMT)	;HL->LIMIT
		POP	AF	;OLD HL
		OR	A
		JP	P,NX1	;STEP > 0
		EX	DE,HL
NX1:		CALL	CKHLDE	;COMPARE WITH LIMIT
		POP	DE	;RESTORE TEXT POINTER
		JP	C,NX2	;OUTSIDE LIMIT
		LD	HL,(LOPLN)	;WITHIN LIMIT, GO
		LD	(CURRNT),HL	;BACK TO THE SAVED
		LD	HL,(LOPPT)	;'CURRNT' AND TEXT
		EX	DE,HL	;POINTER
		RST	30H
NX2:		CALL	POPA	;PURGE THIS LOOP
		RST	30H
;*
;**************************************************************
;*
;* *** REM *** IFF *** INPUT *** & LET (& DEFLT) ***
;*
;* 'REM' CAN BE FOLLOWED BY ANYTHING AND IS IGNORED BY TBI.
;* TBI TREATS IT LIKE AN 'IF' WITH A FALSE CONDITION.
;*
;* 'IF' IS FOLLOWED BY AN EXPR. AS A CONDITION AND ONE OR MORE
;* COMMANDS (INCLUDING OUTHER 'IF'S) SEPERATED BY SEMI-COLONS.
;* NOTE THAT THE WORD 'THEN' IS NOT USED.  TBI EVALUATES THE
;* EXPR. IFF IT IS NON-ZERO, EXECUTION CONTINUES.  IFF THE
;* EXPR. IS ZERO, THE COMMANDS THAT FOLLOWS ARE IGNORED AND
;* EXECUTION CONTINUES AT THE NEXT LINE.
;*
;* 'IPUT' COMMAND IS LIKE THE 'PRINT' COMMAND, AND IS FOLLOWED
;* BY A LIST OF ITEMS.  IFF THE ITEM IS A STRING IN SINGLE OR
;* DOUBLE QUOTES, OR IS A BACK-ARROW, IT HAS THE SAME EFFECT AS
;* IN 'PRINT'.  IFF AN ITEM IS A VARIABLE, THIS VARIABLE NAME IS
;* PRINTED OUT FOLLOWED BY A COLON.  THEN TBI WAITS FOR AN
;* EXPR. TO BE TYPED IN.  THE VARIABLE ISs THEN SET TO THE
;* VALUE OF THIS EXPR.  IFF THE VARIABLE IS PROCEDED BY A STRING
;* (AGAIN IN SINGLE OR DOUBLE QUOTES), THE STRING WILL BE
;* PRINTED FOLLOWED BY A COLON.  TBI THEN WAITS FOR INPUT EXPR.
;* AND SET THE VARIABLE TO THE VALUE OF THE EXPR.
;*
;* IFF THE INPUT EXPR. IS INVALID, TBI WILL PRINT "WHAT?",
;* "HOW?" OR "SORRY" AND REPRINT THE PROMPT AND REDO THE INPUT.
;* THE EXECUTION WILL NOT TERMINATE UNLESS YOU TYPE CONTROL-C.
;* THIS IS HANDLED IN 'INPERR'.
;*
;* 'LET' IS FOLLOWED BY A LIST OF ITEMS SEPERATED BY COMMAS.
;* EACH ITEM CONSISTS OF A VARIABLE, AN EQUAL SIGN, AND AN EXPR.
;* TBI EVALUATES THE EXPR. AND SET THE VARIBLE TO THAT VALUE.
;* TB WILL ALSO HANDLE 'LET' COMMAND WITHOUT THE WORD 'LET'.
;* THIS IS DONE BY 'DEFLT'.
;*
REM:		LD	HL,0O	;*** REM ***
		DB	76O
;*
IFF:		RST	18H	;*** IFF ***
		LD	A,H	;IS THE EXPR.=0?
		OR	L
		JP	NZ,RUNSML	;NO, CONTINUE
		CALL	FNDSKP	;YES, SKIP REST OF LINE
		JP	NC,RUNTSL
		JP	RSTART
;*
INPERR:		LD	HL,(STKINP)	;*** INPERR ***
		LD	SP,HL	;RESTORE OLD SP
		POP	HL	;AND OLD 'CURRNT'
		LD	(CURRNT),HL
		POP	DE	;AND OLD TEXT POINTER
		POP	DE	;REDO INPUT
;*
INPUT		EQU	$	;*** INPUT ***
IP1:		PUSH	DE	;SAVE IN CASE OF ERROR
		CALL	QTSTG	;IS NEXT ITEM A STRING?
		JP	IP2	;NO
		RST	38H	;YES. BUT FOLLOWED BY A
		JP	C,IP4	;VARIABLE?   NO.
		JP	IP3	;YES.  INPUT VARIABLE
IP2:		PUSH	DE	;SAVE FOR 'PRTSTG'
		RST	38H	;MUST BE VARIABLE NOW
		JP	C,QWHAT	;"WHAT?" IT IS NOT?
		LD	A,(DE)	;GET READY FOR 'RTSTG'
		LD	C,A
		SUB	A
		LD	(DE),A
		POP	DE
		CALL	PRTSTG	;PRINT STRING AS PROMPT
		LD	A,C	;RESTORE TEXT
		DEC	DE
		LD	(DE),A
IP3:		PUSH	DE	;SAVE IN CASE OF ERROR
		EX	DE,HL
		LD	HL,(CURRNT)	;ALSO SAVE 'CURRNT'
		PUSH	HL
		LD	HL,IP1	;A NEGATIVE NUMBER
		LD	(CURRNT),HL	;AS A FLAG
		LD	HL,0O	;SAVE SP TOO
		ADD	HL,SP
		LD	(STKINP),HL
		PUSH	DE	;OLD HL
		LD	A,72O	;PRINT THIS TOO
		CALL	GETLN	;AND GET A LINE
IP3A:		LD	DE,BUFFER	;POINTS TO BUFFER
		RST	18H	;EVALUATE INPUT
		NOP	;CAN BE 'CALL ENDCHK'
		NOP
		NOP
		POP	DE	;OK, GET OLD HL
		EX	DE,HL
		LD	(HL),E	;SAVE VALUE IN VAR.
		INC	HL
		LD	(HL),D
		POP	HL	;GET OLD 'CURRNT'
		LD	(CURRNT),HL
		POP	DE	;AND OLD TEXT POINTER
IP4:		POP	AF	;PURGE JUNK IN STACK
		RST	08H	;IS NEXT CH. ','?
		DB	','
		DB	3O
		JP	IP1	;YES, MORE ITEMS.
IP5:		RST	30H
;*
DEFLT:		LD	A,(DE)	;*** DEFLT ***
		CP	0DH	;EMPTY LINE IS OK
		JP	Z,LT1	;ELSE IT IS 'LET'
;*
LET:		CALL	SETVAL	;*** LET ***
		RST	08H	;SET VALUE TO VAR.
		DB	','
		DB	3O
		JP	LET	;ITEM BY ITEM
LT1:		RST	30H	;UNTIL FINISH
;*
;**************************************************************
;*
;* *** EXPR ***
;*
;* 'EXPR' EVALUATES ARITHMETICAL OR LOGICAL EXPRESSIONS.
;* <EXPR>::=<EXPR2>
;*          <EXPR2><REL.OP.><EXPR2>
;* WHERE <REL.OP.> IS ONE OF THE OPERATORSs IN TAB8 AND THE
;* RESULT OF THESE OPERATIONS IS 1 IFF TRUE AND 0 IFF FALSE.
;* <EXPR2>::=(+ OR -)<EXPR3>(+ OR -<EXPR3>)(....)
;* WHERE () ARE OPTIONAL AND (....) ARE OPTIONAL REPEATS.
;* <EXPR3>::=<EXPR4>(<* OR /><EXPR4>)(....)
;* <EXPR4>::=<VARIABLE>
;*           <FUNCTION>
;*           (<EXPR>)
;* <EXPR> IS RECURSIVE SO THAT VARIABLE '@' CAN HAVE AN <EXPR>
;* AS INDEX, FNCTIONS CAN HAVE AN <EXPR> AS ARGUMENTS, AND
;* <EXPR4> CAN BE AN <EXPR> IN PARANTHESE.
;*
;*                 EXPR   CALL EXPR2     THIS IS AT LOC. 18
;*                        PUSH HL        SAVE <EXPR2> VALUE
EXPR1:		LD	HL,TAB8-1	;LOOKUP REL.OP.
		JP	EXEC	;GO DO IT
XP11:		CALL	XP18	;REL.OP.">="
		RET	C	;NO, RETURN HL=0
		LD	L,A	;YES, RETURN HL=1
		RET
XP12:		CALL	XP18	;REL.OP."#"
		RET	Z	;FALSE, RETURN HL=0
		LD	L,A	;TRUE, RETURN HL=1
		RET
XP13:		CALL	XP18	;REL.OP.">"
		RET	Z	;FALSE
		RET	C	;ALSO FALSE, HL=0
		LD	L,A	;TRUE, HL=1
		RET
XP14:		CALL	XP18	;REL.OP."<="
		LD	L,A	;SET HL=1
		RET	Z	;REL. TRUE, RETURN
		RET	C
		LD	L,H	;ELSE SET HL=0
		RET
XP15:		CALL	XP18	;REL.OP."="
		RET	NZ	;FALSE, RETRUN HL=0
		LD	L,A	;ELSE SET HL=1
		RET
XP16:		CALL	XP18	;REL.OP."<"
		RET	NC	;FALSE, RETURN HL=0
		LD	L,A	;ELSE SET HL=1
		RET
XP17:		POP	HL	;NOT REL.OP.
		RET	;RETURN HL=<EXPR2>
XP18:		LD	A,C	;SUBROUTINE FOR ALL
		POP	HL	;REL.OP.'S
		POP	BC
		PUSH	HL	;REVERSE TOP OF STACK
		PUSH	BC
		LD	C,A
		CALL	EXPR2	;GET 2ND <EXPR2>
		EX	DE,HL	;VALUE IN DE NOW
		EX	(SP),HL	;1ST <EXPR2> IN HL
		CALL	CKHLDE	;COMPARE 1ST WITH 2ND
		POP	DE	;RESTORE TEXT POINTER
		LD	HL,0O	;SET HL=0, A=1
		LD	A,1
		RET
;*
EXPR2:		RST	08H	;NEGATIVE SIGN?
		DB	'-'
		DB	6O
		LD	HL,0O	;YES, FAKE '0-'
		JP	XP26	;TREAT LIKE SUBTRACT
XP21:		RST	08H	;POSITIVE SIGN?  IGNORE
		DB	'+'
		DB	0O
XP22:		CALL	EXPR3	;1ST <EXPR3>
XP23:		RST	08H	;ADD?
		DB	'+'
		DB	25O
		PUSH	HL	;YES, SAVE VALUE
		CALL	EXPR3	;GET 2ND<EXPR3>
XP24:		EX	DE,HL	;2ND IN DE
		EX	(SP),HL	;1ST IN HL
		LD	A,H	;COMPARE SIGN
		XOR	D
		LD	A,D
		ADD	HL,DE
		POP	DE	;RESTORE TEXT POINTER
		JP	M,XP23	;1ST 2ND SIGN DIFFER
		XOR	H	;1ST 2ND SIGN EQUAL
		JP	P,XP23	;SO ISp RESULT
		JP	QHOW	;ELSE WE HAVE OVERFLOW
XP25:		RST	08H	;SUBTRACT?
		DB	'-'
		DB	203O
XP26:		PUSH	HL	;YES, SAVE 1ST <EXPR3>
		CALL	EXPR3	;GET 2ND <EXPR3>
		CALL	CHGSGN	;NEGATE
		JP	XP24	;AND ADD THEM
;*
EXPR3:		CALL	EXPR4	;GET 1ST <EXPR4>
XP31:		RST	08H	;MULTIPLY?
		DB	'*'
		DB	54O
		PUSH	HL	;YES, SAVE 1ST
		CALL	EXPR4	;AND GET 2ND <EXPR4>
		LD	B,0O	;CLEAR B FOR SIGN
		CALL	CHKSGN	;CHECK SIGN
		EX	DE,HL	;2ND IN DE NOW
		EX	(SP),HL	;1ST IN HL
		CALL	CHKSGN	;CHECK SIGN OF 1ST
		LD	A,H	;IS HL > 255 ?
		OR	A
		JP	Z,XP32	;NO
		LD	A,D	;YES, HOW ABOUT DE
		OR	D
		EX	DE,HL	;PUT SMALLER IN HL
		JP	NZ,AHOW	;ALSO >, WILL OVERFLOW
XP32:		LD	A,L	;THIS IS DUMB
		LD	HL,0O	;CLEAR RESULT
		OR	A	;ADD AND COUNT
		JP	Z,XP35
XP33:		ADD	HL,DE
		JP	C,AHOW	;OVERFLOW
		DEC	A
		JP	NZ,XP33
		JP	XP35	;FINISHED
XP34:		RST	08H	;DIVIDE?
		DB	'/'
		DB	104O
		PUSH	HL	;YES, SAVE 1ST <EXPR4>
		CALL	EXPR4	;AND GET 2ND ONE
		LD	B,0O	;CLEAR B FOR SIGN
		CALL	CHKSGN	;CHECK SIGN OF 2ND
		EX	DE,HL	;PUT 2ND IN DE
		EX	(SP),HL	;GET 1ST IN HL
		CALL	CHKSGN	;CHECK SIGN OF 1ST
		LD	A,D	;DIVIDE BY 0?
		OR	E
		JP	Z,AHOW	;SAY "HOW?"
		PUSH	BC	;ELSE SAVE SIGN
		CALL	DIVIDE	;USE SUBROUTINE
		LD	H,B	;RESULT IN HL NOW
		LD	L,C
		POP	BC	;GET SIGN BACK
XP35:		POP	DE	;AND TEXT POINTER
		LD	A,H	;HL MUST BE +
		OR	A
		JP	M,QHOW	;ELSE IT IS OVERFLOW
		LD	A,B
		OR	A
		CALL	M,CHGSGN	;CHANGE SIGN IFF NEEDED
		JP	XP31	;LOOK OR MORE TERMS
;*
EXPR4:		LD	HL,TAB4-1	;FIND FUNCTION IN TAB4
		JP	EXEC	;AND GO DO IT
XP40:		RST	38H	;NO, NOT A FUNCTION
		JP	C,XP41	;NOR A VARIABLE
		LD	A,(HL)	;VARIABLE
		INC	HL
		LD	H,(HL)	;VALUE IN HL
		LD	L,A
		RET
XP41:		CALL	TSTNUM	;OR IS IT A NUMBER
		LD	A,B	;# OF DIGIT
		OR	A
		RET	NZ	;OK
PARN:		RST	08H	;NO DIGIT, MUST BE
		DB	'('
		DB	5O
		RST	18H	;"(EXPR)"
		RST	08H
		DB	')'
		DB	1O
XP42:		RET
XP43:		JP	QWHAT	;ELSE SAY: "WHAT?"
;*
RND:		CALL	PARN	;*** RND(EXPR) ***
		LD	A,H	;EXPR MUST BE +
		OR	A
		JP	M,QHOW
		OR	L	;AND NON-ZERO
		JP	Z,QHOW
		PUSH	DE	;SAVE BOTH
		PUSH	HL
		LD	HL,(RANPNT)	;GET MEMORY AS RANDOM
		LD	DE,LSTROM	;NUMBER
		RST	20H
		JP	C,RA1	;WRAP AROUND IFF LAST
		LD	HL,START
RA1:		LD	E,(HL)
		INC	HL
		LD	D,(HL)
		LD	(RANPNT),HL
		POP	HL
		EX	DE,HL
		PUSH	BC
		CALL	DIVIDE	;RND(N)=MOD(M,N)+1
		POP	BC
		POP	DE
		INC	HL
		RET
;*
ABS:		CALL	PARN	;*** ABS(EXPR) ***
		CALL	CHKSGN	;CHECK SIGN
		LD	A,H	;NOTE THAT -32768
		OR	H	;CANNOT CHANGE SIGN
		JP	M,QHOW	;SO SAY: "HOW?"
		RET
SIZE:		LD	HL,(TXTUNF)	;*** SIZE ***
		PUSH	DE	;GET THE NUMBER OF FREE
		EX	DE,HL	;BYTES BETWEEN 'TXTUNF'
SIZEA:		LD	HL,VARBGN	;AND 'VARBGN'
		CALL	SUBDE
		POP	DE
		RET
;*
;*********************************************************
;*
;*   *** OUT *** INP *** WAIT *** POKE *** PEEK *** & USR
;*
;*  OUT I,J(,K,L)
;*
;*  OUTPUTS EXPRESSION 'J' TO PORT 'I', AND MAY BE REPEATED
;*  AS IN DATA 'L' TO PORT 'K' AS MANY TIMES AS NEEDED
;*  THIS COMMAND MODIFIES ;*  THIS COMMAND MODIFIES
;*  THIS COMMAND MODIFY'S A SMALL SECTION OF CODE LOCATED
;*  JUST ABOVE ADDRESS 2K
;*
;*  INP (I)
;*
;*  THIS FUNCTION RETURNS DATA READ FROM INPUT PORT 'I' AS
;*  IT'S VALUE.
;*  IT ALSO MODIFIES CODE JUST ABOVE 2K.
;*
;*  WAIT I,J,K
;*
;*  THIS COMMAND READS THE STATUS OF PORT 'I', EXCLUSIVE OR'S
;*  THE RESULT WITH 'K' IF THERE IS ONE, OR IF NOT WITH 0,
;*  AND'S WITH 'J' AND RETURNS WHEN THE RESULT IS NONZERO.
;*  ITS MODIFIED CODE IS ALSO ABOVE 2K.
;*
;*  POKE I,J(,K,L)
;*
;*  THIS COMMAND WORKS LIKE OUT EXCEPT THAT IT PUTS DATA 'J'
;*  INTO MEMORY LOCATION 'I'.
;*
;*  PEEK (I)
;*
;*  THIS FUNCTION WORKS LIKE INP EXCEPT IT GETS IT'S VALUE
;*  FROM MEMORY LOCATION 'I'.
;*
;*  USR (I(,J))
;*
;*  USR CALLS A MACHINE LANGUAGE SUBROUTINE AT LOCATION 'I'
;*  IF THE OPTIONAL PARAMETER 'J' IS USED ITS VALUE IS PASSED
;*  IN H&L.  THE VALUE OF THE FUNCTION SHOULD BE RETURNED IN H&L.
;*
;************************************************************
;*
OUTCMD:		RST	18H
		LD	A,L
		LD	(OUTIO + 1),A
		RST	08H
		DB	','
		DB	2FH
		RST	18H
		LD	A,L
		CALL	OUTIO
		RST	08H
		DB	','
		DB	03H
		JP	OUTCMD
		RST	30H
WAITCM:		RST	18H
		LD	A,L
		LD	(WAITIO + 1),A
		RST	08H
		DB	','
		DB	1BH
		RST	18H
		PUSH	HL
		RST	08H
		DB	','
		DB	7H
		RST	18H
		LD	A,L
		POP	HL
		LD	H,A
		JP	$ + 2
		LD	H,0
		JP	WAITIO
INP:   		CALL 	PARN
		LD	A,L
		LD	(INPIO + 1),A
		LD	H,0
		JP	INPIO
		JP	QWHAT
POKE:		RST	18H
		PUSH	HL
		RST	08H
		DB	','
		DB	12H
		RST	18H
		LD	A,L
		POP	HL
		LD	(HL),A
		RST	08H
		DB	',',03H
		JP	POKE
		RST	30H
PEEK:		CALL	PARN
		LD	L,(HL)
		LD	H,0
		RET
		JP	QWHAT
USR:		PUSH	BC
		RST	08H
		DB	'(',28	;QWHAT
		RST	18H	;EXPR
		RST	08H
		DB	')',7	;PASPARM
		PUSH	DE
		LD	DE,USRET
		PUSH	DE
		PUSH	HL
		RET	;CALL USR ROUTINE
PASPRM:		RST	08H
		DB	',',14
		PUSH	HL
		RST	18H
		RST	08H
		DB	')',9
		POP	BC
		PUSH	DE
		LD	DE,USRET
		PUSH	DE
		PUSH	BC
		RET	;CALL USR ROUTINE
USRET:		POP	DE
		POP	BC
		RET
		JP	QWHAT
;*
;**************************************************************
;*
;* *** DIVIDE *** SUBDE *** CHKSGN *** CHGSGN *** & CKHLDE ***
;*
;* 'DIVIDE' DIVIDES HL BY DE, RESULT IN BC, REMAINDER IN HL
;*
;* 'SUBDE' SUBTRACTS DE FROM HL
;*
;* 'CHKSGN' CHECKS SIGN OF HL.  IFF +, NO CHANGE.  IFF -, CHANGE
;* SIGN AND FLIP SIGN OF B.
;*
;* 'CHGSGN' CHNGES SIGN OF HL AND B UNCONDITIONALLY.
;*
;* 'CKHLE' CHECKS SIGN OF HL AND DE.  IFF DIFFERENT, HL AND DE
;* ARE INTERCHANGED.  IFF SAME SIGN, NOT INTERCHANGED.  EITHER
;* CASE, HL DE ARE THEN COMPARED TO SET THE FLAGS.
;*
DIVIDE:		PUSH	HL	;*** DIVIDE ***
		LD	L,H	;DIVIDE H BY DE
		LD	H,0
		CALL	DV1
		LD	B,C	;SAVE RESULT IN B
		LD	A,L	;(REMAINDER+L)/DE
		POP	HL
		LD	H,A
DV1:		LD	C,377O	;RESULT IN C
DV2:		INC	C	;DUMB ROUTINE
		CALL	SUBDE	;DIVIDE BY SUBTRACT
		JP	NC,DV2	;AND COUNT
		ADD	HL,DE
		RET
;*
SUBDE:		LD	A,L	;*** SUBDE ***
		SUB	E	;SUBTRACT DE FROM
		LD	L,A	;HL
		LD	A,H
		SBC	A,D
		LD	H,A
		RET
;*
CHKSGN:		LD	A,H	;*** CHKSGN ***
		OR	A	;CHECK SIGN OF HL
		RET	P	;IFF -, CHANGE SIGN
;*
CHGSGN:		LD	A,H	;*** CHGSGN ***
		CPL	;CHANGE SIGN OF HL
		LD	H,A
		LD	A,L
		CPL
		LD	L,A
		INC	HL
		LD	A,B	;AND ALSO FLIP B
		XOR	200O
		LD	B,A
		RET
;*
CKHLDE:		LD	A,H
		XOR	D	;SAME SIGN?
		JP	P,CK1	;YES, COMPARE
		EX	DE,HL	;NO, XCH AND COMP
CK1:		RST	20H
		RET
;*
;**************************************************************
;*
;* *** SETVAL *** FIN *** ENDCHK *** & ERROR (& FRIENDS) ***
;*
;* "SETVAL" EXPECTS A VARIABLE, FOLLOWED BY AN EQUAL SIGN AND
;* THEN AN EXPR.  IT EVALUATES THE EXPR. AND SET THE VARIABLE
;* TO THAT VALUE.
;*
;* "FIN" CHECKS THE END OF A COMMAND.  IFF IT ENDED WITH ";",
;* EXECUTION CONTINUES.  IFF IT ENDED WITH A CR, IT FINDS THE
;* NEXT LINE AND CONTINUE FROM THERE.
;*
;* "ENDCHK" CHECKS IFF A COMMAND IS ENDED WITH CR.  THIS IS
;* REQUIRED IN CERTAIN COMMANDS. (GOTO, RETURN, AND STOP ETC.)
;*
;* "ERROR" PRINTS THE STRING POINTED BY DE (AND ENDS WITH CR).
;* IT THEN PRINTS THE LINE POINTED BY 'CURRNT' WITH A "?"
;* INSERTED AT WHERE THE OLD TEXT POINTER (SHOULD BE ON TOP
;* O THE STACK) POINTS TO.  EXECUTION OF TB IS STOPPED
;* AND TBI IS RESTARTED.  HOWEVER, IFF 'CURRNT' -> ZERO
;* (INDICATING A DIRECT COMMAND), THE DIRECT COMMAND IS NOT
;*  PRINTED.  AND IFF 'CURRNT' -> NEGATIVE # (INDICATING 'INPUT'
;* COMMAND, THE INPUT LINE IS NOT PRINTED AND EXECUTION IS
;* NOT TERMINATED BUT CONTINUED AT 'INPERR'.
;*
;* RELATED TO 'ERROR' ARE THE FOLLOWING:
;* 'QWHAT' SAVES TEXT POINTER IN STACK AND GET MESSAGE "WHAT?"
;* 'AWHAT' JUST GET MESSAGE "WHAT?" AND JUMP TO 'ERROR'.
;* 'QSORRY' AND 'ASORRY' DO SAME KIND OF THING.
;* 'QHOW' AND 'AHOW' IN THE ZERO PAGE SECTION ALSO DO THIS
;*
SETVAL:		RST	38H	;*** SETVAL ***
		JP	C,QWHAT	;"WHAT?" NO VARIABLE
		PUSH	HL	;SAVE ADDRESS OF VAR.
		RST	08H	;PASS "=" SIGN
		DB	'='
		DB	10O
		RST	18H	;EVALUATE EXPR.
		LD	B,H	;VALUE IN BC NOW
		LD	C,L
		POP	HL	;GET ADDRESS
		LD	(HL),C	;SAVE VALUE
		INC	HL
		LD	(HL),B
		RET
SV1:		JP	QWHAT	;NO "=" SIGN
;*
FIN:		RST	08H	;*** FIN ***
		DB	73O
		DB	4O
		POP	AF	;";", PURGE RET ADDR.
		JP	RUNSML	;CONTINUE SAME LINE
FI1:		RST	08H	;NOT ";", IS IT CR?
		DB	0DH
		DB	4O
		POP	AF	;YES, PURGE RET ADDR.
		JP	RUNNXL	;RUN NEXT LINE
FI2:		RET	;ELSE RETURN TO CALLER
;*
ENDCHK:		RST	28H	;*** ENDCHK ***
		CP	0DH	;END WITH CR?
		RET	Z	;OK, ELSE SAY: "WHAT?"
;*
QWHAT:		PUSH	DE	;*** QWHAT ***
AWHAT:		LD	DE,WHAT	;*** AWHAT ***
ERROR:		SUB	A	;*** ERROR ***
		CALL	PRTSTG	;PRINT 'WHAT?', 'HOW?'
		POP	DE	;OR 'SORRY'
		LD	A,(DE)	;SAVE THE CHARACTER
		PUSH	AF	;AT WHERE OLD DE ->
		SUB	A	;AND PUT A 0 THERE
		LD	(DE),A
		LD	HL,(CURRNT)	;GET CURRENT LINE #
		PUSH	HL
		LD	A,(HL)	;CHECK THE VALUE
		INC	HL
		OR	(HL)
		POP	DE
		JP	Z,RSTART	;IFF ZERO, JUST RERSTART
		LD	A,(HL)	;IFF NEGATIVE,
		OR	A
		JP	M,INPERR	;REDO INPUT
		CALL	PRTLN	;ELSE PRINT THE LINE
		DEC	DE	;UPTO WHERE THE 0 IS
		POP	AF	;RESTORE THE CHARACTER
		LD	(DE),A
		LD	A,77O	;PRINTt A "?"
		RST	10H
		SUB	A	;AND THE REST OF THE
		CALL	PRTSTG	;LINE
		JP	RSTART
QSORRY:		PUSH	DE	;*** QSORRY ***
ASORRY:		LD	DE,SORRY	;*** ASORRY ***
		JP	ERROR
;*
;**************************************************************
;*
;* *** GETLN *** FNDLN (& FRIENDS) ***
;*
;* 'GETLN' READS A INPUT LINE INTO 'BUFFER'.  IT FIRST PROMPT
;* THE CHARACTER IN A (GIVEN BY THE CALLER), THEN IT FILLS THE
;* THE BUFFER AND ECHOS.  IT IGNORES LF'S AND NULLS, BUT STILL
;* ECHOS THEM BACK.  RUB-OUT IS USED TO CAUSE IT TO DELETE
;* THE LAST CHARATER (IFF THERE IS ONE), AND ALT-MOD IS USED TO
;* CAUSE IT TO DELETE THE WHOLE LINE AND START IT ALL OVER.
;* 0DHSIGNALS THE END OF A LINE, AND CAUE 'GETLN' TO RETURN.
;*
;* 'FNDLN' FINDS A LINE WITH A GIVEN LINE # (IN HL) IN THE
;* TEXT SAVE AREA.  DE IS USED AS THE TEXT POINTER.  IFF THE
;* LINE IS FOUND, DE WILL POINT TO THE BEGINNING OF THAT LINE
;* (I.E., THE LOW BYTE OF THE LINE #), AND FLAGS ARE NC & Z.
;* IFF THAT LINE IS NOT THERE AND A LINE WITH A HIGHER LINE #
;* IS FOUND, DE POINTS TO THERE AND FLAGS ARE NC & NZ.  IFF
;* WE REACHED THE END OF TEXT SAVE ARE AND CANNOT FIND THE
;* LINE, FLAGS ARE C & NZ.
;* 'FNDLN' WILL INITIALIZE DE TO THE BEGINNING OF THE TEXT SAVE
;* AREA TO START THE SEARCH.  SOME OTHER ENTRIES OF THIS
;* ROUTINE WILL NOT INITIALIZE DE AND DO THE SEARCH.
;* 'FNDLNP' WILL START WITH DE AND SEARCH FOR THE LINE #.
;* 'FNDNXT' WILL BUMP DE BY 2, FIND A 0DHAND THEN START SEARCH.
;* 'FNDSKP' USE DE TO FIND A CR, AND THEN STRART SEARCH.
;*
GETLN:		RST	10H	;*** GETLN ***
		LD	DE,BUFFER	;PROMPT AND INIT
GL1:		CALL	CHKIO	;CHECK KEYBOARD
		JP	Z,GL1	;NO INPUT, WAIT
		CP	177O	;DELETE LST CHARACTER?
		JP	Z,GL3	;YES
		CP	12O	;IGNORE LF
		JP	Z,GL1
		OR	A	;IGNORE NULL
		JP	Z,GL1
		CP	134O	;DELETE THE WHOLE LINE?
		JP	Z,GL4	;YES
		LD	(DE),A	;ELSE, SAVE INPUT
		INC	DE	;AND BUMP POINTER
		CP	15O	;WAS IT CR?
		JP	NZ,GL2	;NO
		LD	A,12O	;YES, GET LINE FEED
		RST	10H	;CALL OUTC AND LINE FEED
		RET	;WE'VE GOT A LINE
GL2:		LD	A,E	;MORE FREE ROOM?
		CP	BUFEND & 0FFH
		JP	NZ,GL1	;YES, GET NEXT INPUT
GL3:		LD	A,E	;DELETE LAST CHARACTER
		CP	BUFFER & 0FFH	;BUT DO WE HAVE ANY?
		JP	Z,GL4	;NO, REDO WHOLE LINE
		DEC	DE	;YES, BACKUP POINTER
		LD	A,'_'	;AND ECHO A BACK-SPACE
		RST	10H
		JP	GL1	;GO GET NEXT INPUT
GL4:		CALL	CRLF	;REDO ENTIRE LINE
		LD	A,136O	;CR, LF AND UP-ARROW
		JP	GETLN
;*
FNDLN:		LD	A,H	;*** FNDLN ***
		OR	A	;CHECK SIGN OF HL
		JP	M,QHOW	;IT CANNT BE -
		LD	DE,TXTBGN	;INIT. TEXT POINTER
;*
FNDLNP		EQU	$	;*** FNDLNP ***
FL1:		PUSH	HL	;SAVE LINE #
		LD	HL,(TXTUNF)	;CHECK IFF WE PASSED END
		DEC	HL
		RST	20H
		POP	HL	;GET LINE # BACK
		RET	C	;C,NZ PASSED END
		LD	A,(DE)	;WE DID NOT, GET BYTE 1
		SUB	L	;IS THIS THE LINE?
		LD	B,A	;COMPARE LOW ORDER
		INC	DE
		LD	A,(DE)	;GET BYTE 2
		SBC	A,H	;COMPARE HIGH ORDER
		JP	C,FL2	;NO, NOT THERE YET
		DEC	DE	;ELSE WE EITHER FOUND
		OR	B	;IT, OR IT IS NOT THERE
		RET	;NC,Z:FOUND; NC,NZ:NO
;*
FNDNXT		EQU	$	;*** FNDNXT ***
		INC	DE	;FIND NEXT LINE
FL2:		INC	DE	;JUST PASSED BYTE 1 & 2
;*
FNDSKP:		LD	A,(DE)	;*** FNDSKP ***
		CP	0DH	;TRY TO FIND 0DH
		JP	NZ,FL2	;KEEP LOOKING
		INC	DE	;FOUND CR, SKIP OVER
		JP	FL1	;CHECK IFF END OF TEXT
;*
;*************************************************************
;*
;* *** PRTSTG *** QTSTG *** PRTNUM *** & PRTLN ***
;*
;* 'PRTSTG' PRINTS A STRING POINTED BY DE.  IT STOPS PRINTING
;* AND RETURNS TO CALÌER WHEN EITHER A 0DHIS PRINTED OR WHEN
;* THE NEXT BYTE IS THE SAME AS WHAT WAS IN A (GIVEN BY THE
;* CALLER).  OLD A IS STORED IN B, OLD B IS LOST.
;*
;* 'QTSTG' LOOKS FOR A BACK-ARROW, SINGLE QUOTE, OR DOUBLE
;* QUOTE.  IFF NONE OF THESE, RETURN TO CALLER.  IFF BACK-ARROW,
;* OUTPUT A 0DHWITHOUT A LF.  IFF SINGLE OR DOUBLE QUOTE, PRINT
;* THE STRING IN THE QUOTE AND DEMANDS A MATCHING UNQUOTE.
;* AFTER THE PRINTING THE NEXT 3 BYTES OF THE CALLER IS SKIPPED
;* OVER (USUALLY A JUMP INSTRUCTION).
;*
;* 'PRTNUM' PRINTS THE NUMBER IN HL.  LEADING BLANKS ARE ADDED
;* IFF NEEDED TO PAD THE NUMBER OF SPACES TO THE NUMBER IN C.
;* HOWEVER, IFF THE NUMBER OF DIGITS IS LARGER THAN THE # IN
;* C, ALL DIGITS ARE PRINTED ANYWAY.  NEGATIVE SIGN IS ALSO
;* PRINTED AND COUNTED IN, POSITIVE SIGN IS NOT.
;*
;* 'PRTLN' PRINSrA SAVED TEXT LINE WITH LINE # AND ALL.
;*
PRTSTG:		LD	B,A	;*** PRTSTG ***
PS1:		LD	A,(DE)	;GET A CHARACTERr
		INC	DE	;BUMP POINTER
		CP	B	;SAME AS OLD A?
		RET	Z	;YES, RETURN
		RST	10H	;ELSE PRINT IT
		CP	0DH	;WAS IT A CR?
		JP	NZ,PS1	;NO, NEXT
		RET	;YES, RETURN
;*
QTSTG:		RST	08H	;*** QTSTG ***
		DB	'"'
		DB	17O
		LD	A,42O	;IT IS A "
QT1:		CALL	PRTSTG	;PRINT UNTIL ANOTHER
		CP	0DH	;WAS LAST ONE A CR?
		POP	HL	;RETURN ADDRESS
		JP	Z,RUNNXL	;WAS CR, RUN NEXT LINE
QT2:		INC	HL	;SKIP 3 BYTES ON RETURN
		INC	HL
		INC	HL
		JP	(HL)	;RETURN
QT3:		RST	08H	;IS IT A ' ?
		DB	47O
		DB	5O
		LD	A,47O	;YES, DO SAME
		JP	QT1	;AS IN "
QT4:		RST	08H	;IS IT BACK-ARROW?
		DB	137O
		DB	10O
		LD	A,215O	;YES, 0DHWITHOUT LF
		RST	10H	;DO IT TWICE TO GIVE
		RST	10H	;TTY ENOUGH TIME
		POP	HL	;RETURN ADDRESS
		JP	QT2
QT5:		RET	;NONE OF ABOVE
;*
PRTNUM:		PUSH	DE	;*** PRTNUM ***
		LD	DE,12O	;DECIMAL
		PUSH	DE	;SAVE AS A FLAG
		LD	B,D	;B=SIGN
		DEC	C	;C=SPACES
		CALL	CHKSGN	;CHECK SIGN
		JP	P,PN1	;NO SIGN
		LD	B,55O	;B=SIGN
		DEC	C	;'-' TAKES SPACE
PN1:		PUSH	BC	;SAVE SIGN & SPACE
PN2:		CALL	DIVIDE	;DEVIDE HL BY 10
		LD	A,B	;RESULT 0?
		OR	C
		JP	Z,PN3	;YES, WE GOT ALL
		EX	(SP),HL	;NO, SAVE REMAINDER
		DEC	L	;AND COUNT SPACE
		PUSH	HL	;HL IS OLD BC
		LD	H,B	;MOVE RESULT TO BC
		LD	L,C
		JP	PN2	;AND DIVIDE BY 10
PN3:		POP	BC	;WE GOT ALL DIGITS IN
PN4:		DEC	C	;THE STACK
		LD	A,C	;LOOK AT SPACE COUNT
		OR	A
		JP	M,PN5	;NO LEADING BLANKS
		LD	A,40O	;LEADING BLANKS
		RST	10H
		JP	PN4	;MORE?
PN5:		LD	A,B	;PRINT SIGN
		RST	10H	;MAYBE - OR NULL
		LD	E,L	;LAST REMAINDER IN E
PN6:		LD	A,E	;CHECK DIGIT IN E
		CP	12O	;10 IS FLAG FOR NO MORE
		POP	DE
		RET	Z	;IFF SO, RETURN
		ADD	A,60O	;ELSE CONVERT TO ASCII
		RST	10H	;AND PRINT THE DIGIT
		JP	PN6	;GO BACK FOR MORE
;*
PRTLN:		LD	A,(DE)	;*** PRTLN ***
		LD	L,A	;LOW ORDER LINE #
		INC	DE
		LD	A,(DE)	;HIGH ORDER
		LD	H,A
		INC	DE
		LD	C,4O	;PRINT 4 DIGIT LINE #
		CALL	PRTNUM
		LD	A,40O	;FOLLOWED BY A BLANK
		RST	10H
		SUB	A	;AND THEN THE TEXT
		CALL	PRTSTG
		RET
;*
;**************************************************************
;*
;* *** MVUP *** MVDOWN *** POPA *** & PUSHA ***
;*
;* 'MVUP' MOVES A BLOCK UP FROM HERE DE-> TO WHERE BC-> UNTIL
;* DE = HL
;*
;* 'MVDOWN' MOVES A BLOCK DOWN FROM WHERE DE-> TO WHERE HL->
;* UNTIL DE = BC
;*
;* 'POPA' RESTORES THE 'FOR' LOOP VARIABLE SAVE AREA FROM THE
;* STACK
;*
;* 'PUSHA' STACKS THE 'FOR' LOOP VARIABLE SAVE AREA INTO THE
;* STACK
;*
MVUP:		RST	20H	;*** MVUP ***
		RET	Z	;DE = HL, RETURN
		LD	A,(DE)	;GET ONE BYTE
		LD	(BC),A	;MOVE IT
		INC	DE	;INCREASE BOTH POINTERS
		INC	BC
		JP	MVUP	;UNTIL DONE
;*
MVDOWN:		LD	A,B	;*** MVDOWN ***
		SUB	D	;TEST IFF DE = BC
		JP	NZ,MD1	;NO, GO MOVE
		LD	A,C	;MAYBE, OTHER BYTE?
		SUB	E
		RET	Z	;YES, RETURN
MD1:		DEC	DE	;ELSE MOVE A BYTE
		DEC	HL	;BUT FIRST DECREASE
		LD	A,(DE)	;BOTH POINTERS AND
		LD	(HL),A	;THEN DO IT
		JP	MVDOWN	;LOOP BACK
;*
POPA:		POP	BC	;BC = RETURN ADDR.
		POP	HL	;RESTORE LOPVAR, BUT
		LD	(LOPVAR),HL	;=0 MEANS NO MORE
		LD	A,H
		OR	L
		JP	Z,PP1	;YEP, GO RETURN
		POP	HL	;NOP, RESTORE OTHERS
		LD	(LOPINC),HL
		POP	HL
		LD	(LOPLMT),HL
		POP	HL
		LD	(LOPLN),HL
		POP	HL
		LD	(LOPPT),HL
PP1:		PUSH	BC	;BC = RETURN ADDR.
		RET
;*
PUSHA:		LD	HL,STKLMT	;*** PUSHA ***
		CALL	CHGSGN
		POP	BC	;BC=RETURN ADDRESS
		ADD	HL,SP	;IS STACK NEAR THE TOP?
		JP	NC,QSORRY	;YES, SORRY FOR THAT.
		LD	HL,(LOPVAR)	;ELSE SAVE LOOP VAR.S
		LD	A,H	;BUT IFF LOPVAR IS 0
		OR	L	;THAT WILL BE ALL
		JP	Z,PU1
		LD	HL,(LOPPT)	;ELSE, MORE TO SAVE
		PUSH	HL
		LD	HL,(LOPLN)
		PUSH	HL
		LD	HL,(LOPLMT)
		PUSH	HL
		LD	HL,(LOPINC)
		PUSH	HL
		LD	HL,(LOPVAR)
PU1:		PUSH	HL
		PUSH	BC	;BC = RETURN ADDR.
		RET
;*
;**************************************************************
;*
;* *** OUTC *** & CHKIO ****
;* THESE ARE THE ONLY I/O ROUTINES IN TBI.
;* 'OUTC' IS CONTROLLED BY A SOFTWARE SWITCH 'OCSW'.  IFF OCSW=0
;* 'OUTC' WILL JUST RETURN TO THE CALLER.  IFF OCSW IS NOT 0,
;* IT WILL OUTPUT THE BYTE IN A.  IFF THAT IS A CR, A LF IS ALSO
;* SEND OUT.  ONLY THE FLAGS MAY BE CHANGED AT RETURN, ALL REG.
;* ARE RESTORED.
;*
;* 'CHKIO' CHECKS THE INPUT.  IFF NO INPUT, IT WILL RETURN TO
;* THE CALLER WITH THE Z FLAG SET.  IFF THERE IS INPUT, Z FLAG
;* IS CLEARED AND THE INPUT BYTE IS IN A.  HOWERER, IFF THE
;* INPUT IS A CONTROL-O, THE 'OCSW' SWITCH IS COMPLIMENTED, AND
;* Z FLAG IS RETURNED.  IFF A CONTROL-C IS READ, 'CHKIO' WILL
;* RESTART TBI AND DO NOT RETURN TO THE CALLER.
;*
;*                 OUTC   PUSH AF        THIS IS AT LOC. 10
;*                        LD   A,OCSW    CHECK SOFTWARE SWITCH
;*                        IOR  A
OC2:		JP	NZ,OC3	;IT IS ON
		POP	AF	;IT IS OFF
		RET	;RESTORE AF AND RETURN
OC3:		POP	AF	;GET OLD A BACK
		PUSH	BC	;SAVE B ON STACK
		PUSH	DE	;AND D
		PUSH	HL	;AND H TOO
		LD	(OUTCAR),A	;SAVE CHARACTER
		LD	E,A	;PUT CHAR. IN E FOR CPM
		LD	C,2	;GET CONOUT COMMAND
		CALL	CPM	;CALL CPM AND DO IT
		LD	A,(OUTCAR)	;GET CHAR. BACK
		CP	0DH	;WAS IT A 'CR'?
		JP	NZ,DONE	;NO, DONE
		LD	E,0AH	;GET LINEFEED
		LD	C,2	;AND CONOUT AGAIN
		CALL	CPM	;CALL CPM
DONE:		LD	A,(OUTCAR)	;GET CHARACTER BACK
IDONE:		POP	HL	;GET H BACK
		POP	DE	;AND D
		POP	BC	;AND B TOO
		RET	;DONE AT LAST
CHKIO:		PUSH	BC	;SAVE B ON STACK
		PUSH	DE	;AND D
		PUSH	HL	;THEN H
		LD	C,11	;GET CONSTAT WORD
		CALL	CPM	;CALL THE BDOS
		OR	A	;SET FLAGS
		JP	NZ,CI1	;IF READY GET CHARACTER
		JP	IDONE	;RESTORE AND RETURN
CI1:		LD	C,1	;GET CONIN WORD
		CALL	CPM	;CALL THE BDOS
		CP	0FH	;IS IT CONTROL-O?
		JP	NZ,CI2	;NO, MORE CHECKING
		LD	A,(OCSW)	;CONTROL-O  FLIP OCSW
		CPL	;ON TO OFF, OFF TO ON
		LD	(OCSW),A	;AND PUT IT BACK
		JP	CHKIO	;AND GET ANOTHER CHARACTER
CI2:		CP	3	;IS IT CONTROL-C?
		JP	NZ,IDONE	;RETURN AND RESTORE IF NOT
		JP	RSTART	;YES, RESTART TBI
LSTROM		EQU	$	;ALL ABOVE CAN BE ROM
OUTIO:		OUT	(0FFH),A
		RET
WAITIO:		IN	A,(0FFH)
		XOR	H
		AND	L
		JP	Z,WAITIO
		RST	30H
INPIO:		IN	A,(0FFH)
		LD	L,A
		RET
OUTCAR:		DB	0	;OUTPUT CHAR. STORAGE
OCSW:		DB	0FFH	;SWITCH FOR OUTPUT
CURRNT:		DW	0	;POINTS TO CURRENT LINE
STKGOS:		DW	0	;SAVES SP IN 'GOSUB'
VARNXT:		DW	0	;TEMPORARY STORAGE
STKINP:		DW	0	;SAVES SP IN 'INPUT'
LOPVAR:		DW	0	;'FOR' LOOP SAVE AREA
LOPINC:		DW	0	;INCREMENT
LOPLMT:		DW	0	;LIMIT
LOPLN:		DW	0	;LINE NUMBER
LOPPT:		DW	0	;TEXT POINTER
RANPNT:		DW	START	;RANDOM NUMBER POINTER
TXTUNF:		DW	TXTBGN	;->UNFILLED TEXT AREA
TXTBGN:		DS	1	;TEXT SAVE AREA BEGINS
MSG1:		DB	7FH,7FH,7FH,"SHERRY BROTHERS TINY BASIC VER. 3.1",0DH
INIT:		LD	A,0FFH
		LD	(OCSW),A	;TURN ON OUTPUT SWITCH
		LD	A,0CH	;GET FORM FEED
		RST	10H	;SEND TO CRT
PATLOP:		SUB	A	;CLEAR ACCUMULATOR
		LD	DE,MSG1	;GET INIT MESSAGE
		CALL	PRTSTG	;SEND IT
LSTRAM:		LD	A,(7)	;GET FBASE FOR TOP
		LD	(RSTART+2),A
		DEC	A	;DECREMENT FOR OTHER POINTERS
		LD	(SS1A+2),A	;AND FIX THEM TOO
		LD	(TV1A+2),A
		LD	(ST3A+2),A
		LD	(ST4A+2),A
		LD	(IP3A+2),A
		LD	(SIZEA+2),A
		LD	(GETLN+3),A
		LD	(PUSHA+2),A
		LD	HL,ST1	;GET NEW START JUMP
		LD	(START+1),HL	;AND FIX IT
		JP	ST1
;	RESTART TABLE
		ORG	0A50H
RSTBL:
		EX	(SP),HL	;*** TSTC OR RST 1 ***
		RST	28H	;IGNORE BLANKS AND
		CP	(HL)	;TEST CHARACTER
		JP	TC1	;REST OF THIS IS AT TC1
;*
CRLF		EQU	0EH	;EXECUTE TIME LOCATION OF THIS INSTRUCTION.
		LD	A,0DH	;*** CRLF ***
;*
		PUSH	AF	;*** OUTC OR RST 2 ***
		LD	A,(OCSW)	;PRINT CHARACTER ONLY
		OR	A	;IFF OCSW SWITCH IS ON
		JP	OC2	;REST OF THIS IS AT OC2
;*
		CALL	EXPR2	;*** EXPR OR RST 3 ***
		PUSH	HL	;EVALUATE AN EXPRESION
		JP	EXPR1	;REST OF IT IS AT EXPR1
		DB	'W'
;*
		LD	A,H	;*** COMP OR RST 4 ***
		CP	D	;COMPARE HL WITH DE
		RET	NZ	;RETURN CORRECT C AND
		LD	A,L	;Z FLAGS
		CP	E	;BUT OLD A IS LOST
		RET
		DB	"AN"
;*
SS1		EQU	28H	;EXECUTE TIME LOCATION OF THIS INSTRUCTION.
		LD	A,(DE)	;*** IGNBLK/RST 5 ***
		CP	40O	;IGNORE BLANKS
		RET	NZ	;IN TEXT (WHERE DE->)
		INC	DE	;AND RETURN THE FIRST
		JP	SS1	;NON-BLANK CHAR. IN A
;*
		POP	AF	;*** FINISH/RST 6 ***
		CALL	FIN	;CHECK END OF COMMAND
		JP	QWHAT	;PRINT "WHAT?" IFF WRONG
		DB	'G'
;*
		RST	28H	;*** TSTV OR RST 7 ***
		SUB	100O	;TEST VARIABLES
		RET	C	;C:NOT A VARIABLE
		JP	TSTV1	;JUMP AROUND RESERVED AREA
; ROUTINE TO COPY RESTART TABLE INTO LOW MEMORY
RST1		EQU	8	;LOCATION FIRST REATART ROUTINE

EOT		EQU	40H	;LAST LOC TO BE FILLED

		ORG	0AA0H
NINIT:		LD	HL,RST1	;POINT TO BEGINNING OF MODEL TABLE
		LD	DE,RSTBL
NXT:		LD	A,(DE)
		LD	(HL),A
		INC	HL
		INC	DE
		LD	A,EOT
		CP	L
		JP	NZ,NXT
		LD	HL,INIT
		LD	(START+1),HL
		JP	START
		ORG	0F00H
TXTEND		EQU	$	;TEXT SAVE AREA ENDS
VARBGN:		DS	2*27	;VARIABLE @(0)
		DS	1	;EXTRA BYTE FOR BUFFER
BUFFER:		DS	80	;INPUT BUFFER
BUFEND		EQU	$	;BUFFER ENDS
		DS	40	;EXTRA BYTES FOR STACK
STKLMT		EQU	$	;TOP LIMIT FOR STACK
		ORG	2000H
STACK		EQU	$	;STACK STARTS HERE
	END
